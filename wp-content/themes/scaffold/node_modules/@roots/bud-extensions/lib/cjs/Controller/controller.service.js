"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Controller = void 0;
const container_1 = require("@roots/container");
const controller_dependencies_1 = require("./controller.dependencies");
/**
 * Extension instance controller
 *
 * @public
 */
class Controller {
    /**
     * Controller constructor
     *
     * @public
     */
    constructor(_app, extension) {
        /**
         * @public
         */
        this.meta = {
            instance: null,
            bound: false,
            mixed: false,
            registered: false,
            booted: false,
        };
        /**
         * @internal
         */
        this._module = {};
        this._app = () => _app;
        this.log = this.app.extensions.log;
        this.meta.instance = this.app.name;
        if (!extension) {
            throw Error(`extension controller constructor: missing module`);
        }
        if (!extension.name) {
            this.app.dump(extension);
            throw Error(`name is a required property for extensions`);
        }
        this.name = extension.name;
        this.options = extension.options;
        Object.assign(this._module, (0, controller_dependencies_1.omit)(extension, ['name', 'options']));
    }
    /**
     * The application instance
     *
     * @public @readonly
     */
    get app() {
        return this._app();
    }
    get moduleLogger() {
        let logger = new controller_dependencies_1.Signale().scope(this.name);
        if (this.app.store.is('features.log', false)) {
            logger.disable();
        }
        return logger;
    }
    /**
     * @public
     * @decorator `@bind`
     */
    get(key) {
        return this._module[key];
    }
    /**
     * @public
     * @decorator `@bind`
     */
    set(key, value) {
        this._module[key] = value;
    }
    /**
     * Extension module name
     *
     * @public
     */
    get name() {
        return this._module.name;
    }
    set name(name) {
        this._module.name = name;
    }
    /**
     * Extension module options
     *
     * @public
     */
    get options() {
        if ((0, controller_dependencies_1.isUndefined)(this._module.options)) {
            return this.app.container();
        }
        if ((0, controller_dependencies_1.isFunction)(this._module.options)) {
            return this.app.container(this._module.options(this.app));
        }
        if (this._module.options instanceof container_1.Container) {
            return this.app.hooks.filter(`extension.${this._module.name}.options`, () => this._module.options);
        }
        if (!(0, controller_dependencies_1.isObject)(this._module.options))
            throw new Error(`${this.name} options must be an object or Container instance`);
        return this.app.hooks.filter(`extension.${this._module.name}.options`, () => this.app.container(this._module.options));
    }
    /**
     * @public
     */
    set options(options) {
        this._module.options = options;
    }
    /**
     * Mutate options
     *
     * @remarks
     * mutation fn receives a container of existing options and returns
     * an object or container of mutated options
     *
     * @param options - mutation fn
     * @public
     */
    mutateOptions(options) {
        if (!(0, controller_dependencies_1.isFunction)(options)) {
            throw new Error(`mutation must be a function that receives a container and returns an object or container`);
        }
        const result = options(this.options);
        if (!(result instanceof container_1.Container) || !(0, controller_dependencies_1.isObject)(result)) {
            throw new Error(`mutation must return an object or container`);
        }
        this.options = result;
    }
    /**
     * Merge options
     *
     * @remarks
     * Supplied options must be an object or container of options to merge
     *
     * @param options - options to merge
     * @public
     */
    mergeOptions(options) {
        if (options instanceof container_1.Container) {
            const optionsContainer = this.options;
            optionsContainer.mergeStore(options.all());
            this.options = optionsContainer;
        }
        if (!(0, controller_dependencies_1.isObject)(options)) {
            throw new Error(`merged options must be an object or container`);
        }
        const optionsContainer = this.options;
        optionsContainer.mergeStore(options);
        this.options = optionsContainer;
    }
    /**
     * Merge option
     *
     * @remarks
     * Supplied options must be an object or container of options to merge
     *
     * @param key - option key
     * @param options - value to merge
     * @public
     */
    mergeOption(key, options) {
        if (!this.options.has(key)) {
            this.app.error(`[${this.name}] key ${key} does not exist`);
            throw new Error(`[${this.name}] key ${key} does not exist`);
        }
        const optionsContainer = this.options;
        optionsContainer.merge(key, options);
        this.options = optionsContainer;
    }
    /**
     * Set an extension option
     *
     * @param key - option key
     * @param value - options value
     * @public
     */
    setOptions(value) {
        if (value instanceof container_1.Container) {
            this.options = value;
            return this;
        }
        if ((0, controller_dependencies_1.isObject)(value)) {
            this.options = this.app.container(value);
            return this;
        }
        this.app.error(`[${this.name}] options must be a container or an object`);
    }
    /**
     * Set an extension option
     *
     * @param key - option key
     * @param value - options value
     * @public
     */
    setOption(key, value) {
        const optionsContainer = this.options;
        optionsContainer.set(key, value);
        this.options = optionsContainer;
    }
    /**
     * Get an extension option
     *
     * @param key - option key
     * @public
     */
    getOption(key) {
        if (!this.options.has(key)) {
            throw new Error(`key ${key} does not exist`);
        }
        return this.options.get(key);
    }
    /**
     * Value determining if the extension should be utilized
     *
     * @public
     */
    make() {
        if (this.when === false)
            return false;
        if (!this._module.make && !this._module.apply)
            return false;
        if (this._module.apply) {
            return this._module;
        }
        if (!this.options.isEmpty())
            this.app.dump(this.options.all(), {
                prefix: `${controller_dependencies_1.chalk.bgBlue(`${this.app.name}`)} ${this.name} ctor options`,
            });
        return (0, controller_dependencies_1.isFunction)(this._module.make)
            ? this._module.make(this.options, this.app)
            : this._module.make;
    }
    /**
     * Value determining if the extension should be utilized
     *
     * @public
     */
    get when() {
        if ((0, controller_dependencies_1.isUndefined)(this._module.when))
            return true;
        if ((0, controller_dependencies_1.isFunction)(this._module.when))
            return this._module.when(this.app, this.options);
        return this._module.when;
    }
    /**
     * Value determining if the extension should be utilized
     *
     * @public
     */
    set when(when) {
        this._module.when = when;
    }
    /**
     * Extension registration event
     *
     * @remarks
     * Calls the {@link Extension} callback
     *
     * @public
     */
    async register() {
        if (!this._module.register) {
            this.meta.registered = true;
            return this;
        }
        if (this.meta.registered)
            return this;
        this.meta.registered = true;
        this.app.project.has(`project.peers.${this.name}.requires`) &&
            (await Promise.all(this.app.project
                .get(`project.peers.${this.name}.requires`)
                .map(async ([name]) => {
                if (!this.app.extensions.get(name).meta.registered) {
                    await this.app.extensions.get(name).register();
                }
            })));
        await this.mixin();
        await this.api();
        if ((0, controller_dependencies_1.isFunction)(this._module.register)) {
            await this._module.register(this.app, this.moduleLogger);
            await this.app.api.processQueue();
            this.moduleLogger.success({
                message: `register called`,
                suffix: controller_dependencies_1.chalk.dim `${this.name}`,
            });
        }
        return this;
    }
    /**
     * @public
     */
    async api() {
        if (!this._module.api) {
            this.meta.bound = true;
            return this;
        }
        if (this.meta.bound)
            return this;
        this.meta.bound = true;
        this.app.project.has(`project.peers.${this.name}.requires`) &&
            (await Promise.all(this.app.project
                .get(`project.peers.${this.name}.requires`)
                .map(async ([name]) => {
                if (!this.app.extensions.get(name).meta.bound) {
                    await this.app.extensions.get(name).api();
                }
            })));
        const methodMap = (0, controller_dependencies_1.isFunction)(this._module.api)
            ? await this._module.api(this.app)
            : this._module.api;
        if (!(0, controller_dependencies_1.isObject)(methodMap))
            throw new Error(`${this.name}] api must be an object or return an object`);
        Object.entries(methodMap).forEach(([name, method]) => {
            if (!(0, controller_dependencies_1.isFunction)(method))
                throw new Error(`${name} must be a function`);
            this.app.api.set(name, method.bind ? method.bind(this.app) : method);
            this.app.api.bindFacade(name);
            if ((0, controller_dependencies_1.isUndefined)(this.app[name]) || !(0, controller_dependencies_1.isFunction)(this.app[name]))
                throw new Error(`there was a problem binding the ${name} fn to bud (${this.name})`);
        });
        return this;
    }
    /**
     * @public
     */
    async mixin() {
        if (!this._module.mixin) {
            this.meta.mixed = true;
            return this;
        }
        if (this.meta.mixed)
            return this;
        this.meta.mixed = true;
        this.app.project.has(`project.peers.${this.name}.requires`) &&
            (await Promise.all(this.app.project
                .get(`project.peers.${this.name}.requires`)
                .map(async ([name]) => {
                if (!this.app.extensions.get(name).meta.mixed) {
                    await this.app.extensions.get(name).mixin();
                }
            })));
        let classMap;
        if ((0, controller_dependencies_1.isFunction)(this._module.mixin)) {
            classMap = await this._module.mixin(this.app);
        }
        else {
            classMap = this._module.mixin;
        }
        if (!(0, controller_dependencies_1.isObject)(classMap))
            return;
        this.app.mixin(classMap);
        Object.entries(classMap).forEach(([k, v]) => {
            this.moduleLogger.success({
                message: `registered ${this.app.name}.${k}`,
                suffix: controller_dependencies_1.chalk.dim `${this.name}`,
            });
        });
    }
    /**
     * Extension boot event
     *
     * @remarks
     * Calls the {@link @roots/bud-framework#Module.boot} callback
     *
     * @public
     * @decorator `@bind`
     */
    async boot() {
        if (!this._module.boot) {
            this.meta.booted = true;
            return this;
        }
        if (this.meta.booted)
            return this;
        this.meta.booted = true;
        this.app.project.has(`project.peers.${this.name}.requires`) &&
            (await Promise.all(this.app.project
                .get(`project.peers.${this.name}.requires`)
                .map(async ([name]) => {
                if (!this.app.extensions.get(name).meta.boot) {
                    await this.app.extensions.get(name).boot();
                }
            })));
        if ((0, controller_dependencies_1.isFunction)(this._module.boot)) {
            await this._module.boot(this.app, this.moduleLogger);
            await this.app.api.processQueue();
            this.moduleLogger.success({
                message: `${this.name} booted`,
            });
        }
        return this;
    }
}
__decorate([
    controller_dependencies_1.bind
], Controller.prototype, "get", null);
__decorate([
    controller_dependencies_1.bind
], Controller.prototype, "set", null);
__decorate([
    controller_dependencies_1.bind
], Controller.prototype, "mutateOptions", null);
__decorate([
    controller_dependencies_1.bind
], Controller.prototype, "mergeOptions", null);
__decorate([
    controller_dependencies_1.bind
], Controller.prototype, "mergeOption", null);
__decorate([
    controller_dependencies_1.bind
], Controller.prototype, "setOptions", null);
__decorate([
    controller_dependencies_1.bind
], Controller.prototype, "setOption", null);
__decorate([
    controller_dependencies_1.bind
], Controller.prototype, "getOption", null);
__decorate([
    controller_dependencies_1.bind
], Controller.prototype, "make", null);
__decorate([
    controller_dependencies_1.bind
], Controller.prototype, "register", null);
__decorate([
    controller_dependencies_1.bind
], Controller.prototype, "api", null);
__decorate([
    controller_dependencies_1.bind
], Controller.prototype, "mixin", null);
__decorate([
    controller_dependencies_1.bind
], Controller.prototype, "boot", null);
exports.Controller = Controller;
