"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Extensions = void 0;
const bud_framework_1 = require("@roots/bud-framework");
const Controller_1 = require("../Controller");
const extensions_dependencies_1 = require("./extensions.dependencies");
/**
 * Extensions Service
 *
 * @remarks
 * Manages extension controllers
 *
 * @public
 */
class Extensions extends bud_framework_1.Service {
    constructor() {
        super(...arguments);
        /**
         * Extensions queued for registration
         *
         * @public
         */
        this.queue = [];
    }
    /**
     * Controller factory
     *
     * @public
     */
    makeController(extension) {
        const controller = new Controller_1.Controller(this.app, extension);
        return controller;
    }
    async setController(extension) {
        const controller = this.makeController(extension);
        this.set(controller.name, controller);
    }
    /**
     * @override
     * @public
     */
    async booted() {
        /**
         * Handle in-built extensions
         */
        await Promise.all(this.getEntries().map(async ([key, extension]) => {
            this.setController(extension);
            this.log('success', { message: `${key} instantiated` });
        }));
        await this.registerExtensions();
        await this.bootExtensions();
        await this.injectExtensions();
    }
    /**
     * Inject extension modules
     *
     * @public
     * @decorator `@bind`
     */
    async injectExtensions() {
        if (this.app.store.is('features.inject', false)) {
            this.log('log', 'injection disabled');
            return;
        }
        try {
            const modules = Object.values(this.app.project.peers.modules)
                .filter(Boolean)
                .filter(({ bud }) => bud?.type === 'extension');
            await Promise.all(modules.map(async (record) => {
                await this.importExtension(record);
            }));
            await modules.reduce(async (promised, record) => {
                await promised;
                await this.registerExtension(this.get(record.name));
            }, Promise.resolve());
            await modules.reduce(async (promised, record) => {
                await promised;
                await this.bootExtension(this.get(record.name));
            }, Promise.resolve());
        }
        catch (e) {
            this.app.error(e);
        }
    }
    async importExtension(extension) {
        this.log('log', `importing ${extension.name}`);
        const importedModule = await Promise.resolve().then(() => __importStar(require(extension.name)));
        const importedExtension = importedModule.default
            ? importedModule.default
            : importedModule;
        if (this.has(importedExtension.name))
            return;
        await this.setController(importedExtension);
    }
    /**
     * @public
     */
    async registerExtension(extension) {
        try {
            if (!extension)
                return;
            this.app.log('registering', extension.name);
            await extension.mixin();
            await extension.api();
            await extension.register();
        }
        catch (err) {
            this.app.log(extension);
            throw new Error(err);
        }
    }
    /**
     * @public
     */
    async bootExtension(extension) {
        try {
            if (!extension)
                return;
            this.app.log('booting', extension.name);
            await extension.boot();
        }
        catch (err) {
            throw new Error(err);
        }
    }
    /**
     * @public
     */
    async registerExtensions() {
        this.log('time', 'registering');
        await this.getEntries().reduce(async (promised, [_key, controller]) => {
            await promised;
            await this.registerExtension(controller);
        }, Promise.resolve());
        this.log('timeEnd', 'registering');
    }
    /**
     * @public
     */
    async bootExtensions() {
        this.log('time', 'booting');
        await this.getEntries().reduce(async (promised, [key, controller]) => {
            await promised;
            await this.bootExtension(controller);
        }, Promise.resolve());
        this.log('timeEnd', 'booting');
    }
    /**
     * Add a {@link Controller} to the container
     *
     * @public
     * @decorator `@bind`
     */
    async add(extension) {
        if (this.has(extension.name)) {
            this.log('info', `${extension.name} already exists. skipping.`);
            return;
        }
        await this.setController(extension);
        await this.registerExtension(this.get(extension.name));
        await this.bootExtension(this.get(extension.name));
    }
    /**
     * Queue an extension to be added to the container before the build process.
     *
     * @remarks
     * Useful for extensions which cannot be added in an awaitable context (like a user config)
     *
     * @public
     * @decorator `@bind`
     */
    enqueue(extension) {
        this.queue.push(extension);
        return this.app;
    }
    /**
     * @public
     */
    async processQueue() {
        if (!this.queue.length)
            return;
        await Promise.all(this.queue.map(this.add));
        this.queue = [];
    }
    /**
     * Returns an array of plugin instances which have been registered to the
     * container and are set to be used in the compilation
     *
     * @returns An array of plugin instances
     *
     * @public
     * @decorator `@bind`
     */
    async make() {
        this.log('time', 'extensions.make');
        await this.processQueue();
        const plugins = this.getValues()
            .filter(controller => controller._module.make)
            .map((controller) => {
            const result = controller.make();
            if (!result) {
                this.log('log', `${controller.name} will not be used in the compilation`);
                return result;
            }
            this.log('success', `${controller.name} will be used in the compilation`);
            return result;
        })
            .filter(Boolean);
        this.log('timeEnd', 'extensions.make');
        return plugins;
    }
}
__decorate([
    extensions_dependencies_1.bind
], Extensions.prototype, "setController", null);
__decorate([
    extensions_dependencies_1.bind
], Extensions.prototype, "booted", null);
__decorate([
    extensions_dependencies_1.bind
], Extensions.prototype, "injectExtensions", null);
__decorate([
    extensions_dependencies_1.bind
], Extensions.prototype, "importExtension", null);
__decorate([
    extensions_dependencies_1.bind
], Extensions.prototype, "registerExtension", null);
__decorate([
    extensions_dependencies_1.bind
], Extensions.prototype, "bootExtension", null);
__decorate([
    extensions_dependencies_1.bind
], Extensions.prototype, "registerExtensions", null);
__decorate([
    extensions_dependencies_1.bind
], Extensions.prototype, "bootExtensions", null);
__decorate([
    extensions_dependencies_1.bind
], Extensions.prototype, "add", null);
__decorate([
    extensions_dependencies_1.bind
], Extensions.prototype, "enqueue", null);
__decorate([
    extensions_dependencies_1.bind
], Extensions.prototype, "processQueue", null);
__decorate([
    extensions_dependencies_1.bind
], Extensions.prototype, "make", null);
exports.Extensions = Extensions;
