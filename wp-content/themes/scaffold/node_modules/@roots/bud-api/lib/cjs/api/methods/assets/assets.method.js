"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assets = void 0;
const lodash_1 = require("lodash");
const path_1 = require("path");
const assets = async function assets(...request) {
    /**
     * tsc will complain about `this` context being lost
     * when destructuring bud even though the context of
     * this function will be bound.
     */
    const ctx = this;
    /**
     * We know it's not a directory
     * - when it ends with a globstar
     *
     * We'll say it's a directory when:
     * - a pattern ends with `/`
     * - a pattern has segments and it's last path segment does not contain a `.`
     * - a pattern has no segments and does not contain a dot
     */
    const isDirectoryish = (pattern) => {
        if (pattern.endsWith('*'))
            return false;
        if (pattern.endsWith('/'))
            return true;
        if (pattern.includes('/') && !pattern.split('/').pop().includes('.'))
            return true;
        return !pattern.split('/').pop().includes('.');
    };
    /**
     * Return a wildcard glob for a given path
     */
    const toWildcard = (pattern) => (0, path_1.normalize)(`${pattern}/**/*`);
    /**
     * Replace a leading dot with the project path
     */
    const fromDotRel = (pattern) => pattern?.startsWith('./') ? pattern.replace('./', ctx.path()) : pattern;
    /**
     * Take an input string and return a {@link CopyPlugin.ObjectPattern}
     */
    const makePatternObject = (input) => {
        /**
         * Process raw user input.
         *
         * - Replace leading dot with project path
         * - Append wildcard glob to directory requests
         */
        const from = isDirectoryish(input)
            ? fromDotRel(toWildcard(input))
            : fromDotRel(input);
        /**
         * Test if input starts with a given string
         */
        const test = (test) => from.startsWith(test);
        /**
         * Return path that serves as base of request
         *
         * @remarks
         * In order of priority:
         *  - project `src` path
         *  - project path
         *  - raw input
         */
        const context = () => {
            if (test('.'))
                return ctx.path();
            if (test('/'))
                return;
            else
                return ctx.path('@src');
        };
        return {
            from,
            context: context(),
            noErrorOnMissing: true,
        };
    };
    /**
     * Handle tuple set
     *
     * @param tuple - [origin, destination]
     * @returns
     */
    const makeFromTo = ([from, to]) => {
        /**
         * Process raw user input.
         *
         * - Replace leading dot with project path
         * - Append wildcard glob to directory requests
         */
        from = isDirectoryish(from)
            ? fromDotRel(toWildcard(from))
            : fromDotRel(from);
        return {
            from,
            to,
            noErrorOnMissing: true,
        };
    };
    /**
     * Parse a request item
     */
    const parse = (request) => {
        return (0, lodash_1.isString)(request) ? makePatternObject(request) : request;
    };
    const appearsTupled = (0, lodash_1.isArray)(request[0]) && (0, lodash_1.isArray)(request[0][0]);
    if (appearsTupled) {
        ctx.extensions
            .get('copy-webpack-plugin')
            .mergeOption('patterns', request.flat().map(makeFromTo));
        return ctx;
    }
    ctx.extensions
        .get('copy-webpack-plugin')
        .mergeOption('patterns', request.flat().map(parse));
    return ctx;
};
exports.assets = assets;
