import { HighlightOptions, PrettyFormatOptions } from '@roots/bud-support';
import { parsers } from '@roots/bud-support';
import { Container } from '@roots/container';
import { Api, Build, Cache, Compiler, Context, Dashboard, Dependencies, Env, Extension, Extensions, Hooks, Logger, Server, Services, Store } from '../';
import { Project } from '../Project';
import { lifecycle } from './lifecycle';
import * as methods from './methods';
/**
 * Base {@link Framework} class
 *
 * @public
 */
export declare abstract class Framework {
    /**
     * Concrete implementation of the {@link Framework}
     *
     * @internal @virtual
     */
    abstract implementation: Constructor;
    context: Context;
    /**
     * Framework name
     *
     * @remarks
     * The name of the parent compiler is used as a base when sourcing configuration files.
     * So, in an implementation that uses the name `app`, the Framework will be sourcing
     * `app.config.js`, `app.development.config.js`, etc.
     *
     * @public
     */
    private _name;
    get name(): string;
    /**
     * Compilation mode
     *
     * @remarks
     * Either `production` or `development`. Unlike webpack, there is no 'none' mode.
     *
     * @defaultValue 'production'
     */
    private _mode;
    get mode(): 'development' | 'production';
    /**
     * Parent {@link Framework} instance
     *
     * @remarks
     * Is `null` if the current instance is the parent instance.
     *
     * @defaultValue null
     */
    root: Framework | null;
    /**
     * True when current instance is the parent instance
     *
     * @readonly
     */
    get isRoot(): boolean;
    /**
     * True when current instance is a child instance
     *
     * @readonly
     */
    get isChild(): boolean;
    /**
     * {@link @roots/container#Container} of child {@link Framework} instances
     *
     * @remarks
     * Is `null` if the current instance is a child instance.
     *
     * @defaultValue null
     */
    children: Container<Record<string, Framework>>;
    /**
     * True when {@link Framework} has children
     *
     * @readonly
     */
    get hasChildren(): boolean;
    /**
     * Framework services
     *
     * @remarks
     * Can be set directly on the child instance or passed as a property in the {@link Options}.
     *
     * @public
     */
    services: Services;
    /**
     * Macros for assisting with common config tasks
     *
     * @public
     */
    api: Api;
    /**
     * Build service
     *
     * @public
     */
    build: Build;
    /**
     * Determines cache validity and generates cache keys.
     *
     * @public
     */
    cache: Cache;
    /**
     * Compiles configuration and stats/errors/progress reporting.
     *
     * @public
     */
    compiler: Compiler;
    /**
     * Presents build progress, stats and errors from {@link Compiler} and {@link Server}
     * over the CLI.
     *
     * @public
     */
    dashboard: Dashboard;
    /**
     * Utilities for interfacing with user package manager software
     *
     * @public
     */
    dependencies: Dependencies;
    /**
     * Project information and peer dependency management utilities
     *
     * @public
     */
    project: Project;
    /**
     * .env container
     *
     * @public
     */
    env: Env;
    /**
     * Container service for {@link Framework} extensions.
     *
     * @remarks
     * Extensions can be defined as a {@link Module}, which is more generic.
     *
     * They can also be defined as a {@link WebpackPlugin} which is a {@link Module}
     * specifically yielding a {@link WebpackPluginInstance}.
     *
     * When adding a {@link Module} or {@link Plugin} to the container
     * with {@link Extensions.add} it is cast to the {@link Extension} type.
     *
     * @public
     */
    extensions: Extensions;
    /**
     * Service allowing for fitering {@link Framework} values through callbacks.
     *
     * @example Add a new entry to the `webpack.externals` configuration:
     * ```ts
     * hooks.on(
     *   'build/externals',
     *   externals => ({
     *     ...externals,
     *     $: 'jquery',
     *   })
     * )
     * ```
     *
     * @example Change the `webpack.output.filename` format:
     * ```ts
     * hooks.on(
     *   'build.output.filename',
     *   () => '[name].[hash:4]',
     * )
     * ```
     *
     * @public
     */
    hooks: Hooks;
    /**
     * Logging service
     *
     * @public
     */
    logger: Logger;
    /**
     * Development server
     *
     * @public
     */
    server: Server.Service;
    /**
     * Container service for holding configuration values
     *
     * @public
     */
    store: Store;
    /**
     * True when {@link Framework.mode} is `production`
     *
     * @public
     */
    get isProduction(): boolean;
    /**
     * True when {@link Framework.mode} is `development`
     *
     * @public
     */
    get isDevelopment(): boolean;
    /**
     * True if ts-node has been invoked
     *
     * @public
     */
    usingTsNode: boolean;
    /**
     * Initially received options
     *
     * @public
     */
    options: Options;
    /**
     * Class constructor
     *
     * @param options - {@link Framework.Options | Framework constructor options}
     *
     * @public
     */
    constructor(options: Options);
    /**
     * @internal
     */
    lifecycle: lifecycle;
    /**
     * Access a value which may or may not be a function.
     *
     * @remarks
     * If a value is a function **access** will call that function and return the result.
     *
     * If the value is not a function **access** will return its value.
     *
     * @example
     * ```js
     * const isAFunction = (option) => `option value: ${option}`
     * const isAValue = 'option value: true'
     *
     * access(isAFunction, true) // => `option value: true`
     * access(isAValue) // => `option value: true`
     * ```
     *
     * @public
     */
    maybeCall: methods.maybeCall;
    /**
     * Gracefully shutdown {@link Framework} and registered {@link @roots/bud-framework#Service | Service instances}
     *
     * @example
     * ```js
     * bud.close()
     * ```
     *
     * @public
     */
    close: methods.close;
    /**
     * Create a new {@link Container} instance
     *
     * @example
     * ```js
     * const myContainer = bud.container({key: methods.'value'})
     *
     * myContainer.get('key') // returns 'value'
     * ```
     *
     * @public
     */
    container: methods.container;
    /**
     * Returns a {@link Framework | Framework instance} from the {@link Framework.children} container
     *
     * @remarks
     * An optional {@link tap} function can be provided to configure the {@link Framework} instance.
     *
     * @example
     * ```js
     * const name = 'plugin'
     * const tapFn = plugin => plugin.entry('main', 'main.js')
     *
     * bud.get(name, tapFn)
     * ```
     *
     * @public
     */
    get: methods.get;
    /**
     * Instantiate a child instance and add to {@link Framework.children} container
     *
     * @remarks
     * **make** takes two parameters:
     *
     * - The **name** of the new compiler
     * - An optional callback to use for configuring the compiler.
     *
     * @example
     * ```js
     * bud.make('scripts', child => child.entry('app', 'app.js'))
     * ```
     *
     * @public
     */
    make: methods.make;
    /**
     * Returns a {@link Locations} value as an absolute path
     *
     * @public
     */
    path: methods.path;
    /**
     * Pipe a value through an array of functions. The return value of each callback is used as input for the next.
     *
     * @remarks
     * If no value is provided the value is assumed to be the {@link Framework} itself
     *
     * {@link sequence} is a non-mutational version of this method.
     *
     * @example
     * ```js
     * app.pipe(
     *   [
     *     value => value + 1,
     *     value => value + 1,
     *   ],
     *   1, // initial value
     * ) // resulting value is 3
     * ```
     *
     * @public
     */
    pipe: methods.pipe;
    /**
     * Public path
     *
     * @remarks
     * Path from web root to assets
     *
     * @public
     */
    publicPath: methods.publicPath;
    /**
     * Set a {@link @roots/bud-framework#Location | Location} value
     *
     * @remarks
     * The {@link Location.project} should be an absolute path.
     * All other directories should be relative (src, dist, etc.)
     * @see {@link Locations}
     *
     * @example
     * ```js
     * bud.setPath('@src', 'custom/src')
     * ```
     *
     * @param this - {@link Framework}
     * @param args - path parts
     *
     * @public
     */
    setPath: methods.setPath;
    /**
     * By default it is assumed that assets are served from webroot (`/`).
     * You can use this method to replace this value for apps served from
     * a subdirectory.
     *
     * @example
     * Set the default path using a string
     *
     * ```js
     * app.setPublicPath('/app/themes/sage/dist')
     * ```
     *
     * @example
     * Set the publicPath using a function.
     *
     * ```js
     * app.setPublicPath(publicPath => {
     *   return `web/assets/${publicPath}`
     * })
     * ```
     *
     * @public
     */
    setPublicPath: methods.setPublicPath;
    /**
     * Run a value through an array of syncronous, non-mutational functions.
     *
     * @remarks
     * Unlike {@link pipe} the value returned from each function is ignored.
     *
     * @public
     */
    sequence: methods.sequence;
    /**
     * Execute a callback
     *
     * @remarks
     * Callback is provided {@link Framework | the Framework instance} as a parameter.
     *
     * @example
     * ```js
     * bud.tap(bud => {
     *   // do something with bud
     * })
     * ```
     *
     * @example
     * Lexical scope is bound to Framework where applicable, so it
     * is possible to reference the Framework using `this`.
     *
     * ```js
     * bud.tap(function () {
     *  // do something with this
     * })
     * ```
     *
     * @public
     */
    tap: methods.tap;
    /**
     * Executes a function if a given test is `true`.
     *
     * @remarks
     * - The first parameter is the conditional check.
     * - The second parameter is the function to run if `true`.
     * - The third parameter is optional; executed if the conditional is not `true`.
     *
     * @example
     * Only produce a vendor bundle when running in `production` {@link Mode}:
     *
     * ```js
     * bud.when(bud.isProduction, () => bud.vendor())
     * ```
     *
     * @example
     * Use `eval` sourcemap in development mode and `hidden-source-map` in production:
     *
     * ```js
     * bud.when(
     *   bud.isDevelopment,
     *   () => bud.devtool('eval'),
     *   () => bud.devtool('hidden-source-map'),
     * )
     * ```
     *
     * @public
     */
    when: methods.when;
    /**
     * Bind method to {@link Framework | Framework instance}
     *
     * @public
     */
    bindMethod: methods.bindMethod;
    /**
     * Adds a class as a property of the Framework
     *
     * @public
     */
    mixin: typeof methods.mixin;
    /**
     * Read and write json files
     *
     * @public
     */
    json: typeof parsers.json5;
    /**
     * Read and write yaml files
     *
     * @public
     */
    yml: typeof parsers.yml;
    /**
     * Log a message
     *
     * @public
     * @decorator `@bind`
     */
    log(...messages: any[]): this;
    /**
     * Log an `info` level message
     *
     * @public
     * @decorator `@bind`
     */
    info(...messages: any[]): this;
    /**
     * Log a `success` level message
     *
     * @public
     * @decorator `@bind`
     */
    success(...messages: any[]): this;
    /**
     * Log a `warning` level message
     *
     * @public
     * @decorator `@bind`
     */
    warn(...messages: any[]): this;
    /**
     * Log a `warning` level message
     *
     * @public
     * @decorator `@bind`
     */
    time(...messages: any[]): this;
    /**
     * Log a `warning` level message
     *
     * @public
     * @decorator `@bind`
     */
    await(...messages: any[]): this;
    /**
     * Log a `warning` level message
     *
     * @public
     * @decorator `@bind`
     */
    complete(...messages: any[]): this;
    /**
     * Log a `warning` level message
     *
     * @public
     * @decorator `@bind`
     */
    timeEnd(...messages: any[]): this;
    /**
     * Log and display a debug message.
     *
     * @remarks
     * This error is fatal and will kill the process
     *
     * @public
     * @decorator `@bind`
     */
    debug(...messages: any[]): void;
    /**
     * Log and display an error.
     *
     * @remarks
     * This error is fatal and will kill the process
     *
     * @public
     * @decorator `@bind`
     */
    error(...messages: any[]): void;
    /**
     * Dump object and return Framework
     */
    dump(obj: any, options?: PrettyFormatOptions & HighlightOptions & {
        prefix: string;
    }): Framework;
    /**
     * timer util
     *
     * @public
     */
    _hrtime: [number, number];
    _hrdiff(): number;
    _hrdone: number;
}
/**
 * Framework Constructor
 */
export declare type Constructor = new (options: Options) => Framework;
/**
 * Constructor options
 *
 * @public
 */
export interface Options {
    /**
     * Application context
     *
     * @public
     */
    context?: Context;
    /**
     * name
     *
     * @defaultValue `bud`
     *
     * @public
     */
    name?: string;
    /**
     * Build mode
     *
     * @remarks
     * One of: `production` | `development`
     *
     * @defaultValue `production`
     *
     * @public
     */
    mode?: 'production' | 'development';
    /**
     * The object providing initial configuration values.
     *
     * @remarks
     * It is probable that extensions and services will modify
     * values introduced in this object. If you are looking to simply modify
     * configuration values it is generally a better idea to use the
     * {@link @roots/bud-hooks#Hooks | Hooks class} instead.
     *
     * @public
     */
    config?: Partial<Store.Repository>;
    /**
     * Framework services
     * @public
     */
    services?: Services;
    /**
     * @internal
     */
    childOf?: Framework;
    /**
     * Extensions to be registered
     *
     * @public
     */
    extensions?: () => Record<string, Extension.Module | Extension.CompilerPlugin>;
}
//# sourceMappingURL=index.d.ts.map