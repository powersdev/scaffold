"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Service = void 0;
const bud_support_1 = require("@roots/bud-support");
const bud_support_2 = require("@roots/bud-support");
const Bootstrapper_1 = require("./Bootstrapper");
const { isString, isUndefined } = bud_support_2.lodash;
/**
 * Atomic unit of {@link Framework} functionality.
 *
 * @remarks
 * The {@link Service} interface extends {@link Bootstrapper}, which provides {@link @roots/container#Container}
 * and {@link Framework} access
 *
 * A {@link Service} is tapped through a series of callbacks at different points in the build.
 *
 * All of the callbacks are optional:
 *
 * - {@link Service.bootstrap} is called when the Service is instantiated (but before all services are guaranteed to be instantiated).
 *
 * - {@link Service.bootstrapped} is called once all Services have been instantiated.
 *
 * - {@link Service.register} is intended for Services to register functionalities, modules, and bind functions and classes.
 *
 * - {@link Service.registered} is called after all {@link Service.register} callbacks are complete.
 *
 * - {@link Service.boot} is called once all services are registered. It should be safe for Services to reference one another.
 *
 * - {@link Service.booted} is called after all {@link Service.boot} callbacks are complete.
 *
 * @typeParam Repository - {@link Repository} typing, if applicable
 *
 * @public
 */
class Service extends Bootstrapper_1.Bootstrapper {
    constructor() {
        super(...arguments);
        /**
         * Service identifier
         *
         * @public
         */
        this.ident = 'service';
    }
    /**
     * Service scoped logger
     *
     * @public
     */
    get logger() {
        return this.app.logger.instance;
    }
    /**
     * Dump the service repository
     *
     * @public
     * @decorator `@bind`
     */
    dump(options) {
        this.app.log({
            message: (0, bud_support_2.highlight)((0, bud_support_1.format)(this.repository, {
                maxDepth: 2,
                ...options,
            })),
            prefix: this.ident,
        });
    }
    /**
     * Log a message
     *
     * @public
     * @decorator `@bind`
     */
    log(type, ...messages) {
        this.app.store.is('features.log', true) &&
            this.logger[type](...messages.reduce((acc, loggedItem) => {
                if (typeof loggedItem !== 'string' &&
                    !isUndefined(loggedItem?.suffix) &&
                    isString(loggedItem?.suffix)) {
                    loggedItem.suffix = bud_support_2.chalk.dim(loggedItem.suffix.replace(this.app.context.projectDir, '.'));
                }
                return [...acc, loggedItem];
            }, []));
        return this;
    }
}
__decorate([
    bud_support_2.bind
], Service.prototype, "dump", null);
__decorate([
    bud_support_2.bind
], Service.prototype, "log", null);
exports.Service = Service;
