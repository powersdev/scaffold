"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.path = exports.parseAlias = void 0;
const node_path_1 = require("node:path");
const parseAlias = (app, base) => {
    /* Normalize base path to an array of path segments */
    let [ident, ...parts] = base.includes(node_path_1.sep) ? base.split(node_path_1.sep) : [base];
    /* If there is no match for ident there is a problem */
    !app.hooks.has(`location.${ident}`) &&
        app.error(`\`${ident}\` is not a registered path. It must be defined with bud.setPath`);
    /* Replace base path */
    ident = app.hooks.filter(`location.${ident}`);
    /* If segments were passed, resolve */
    return parts.length ? (0, node_path_1.resolve)(ident, ...parts) : ident;
};
exports.parseAlias = parseAlias;
const path = function (base, ...segments) {
    const app = this;
    /* Exit early with projectDir if no path was passed */
    if (!base)
        return app.context.projectDir;
    const fileHandles = (pathString) => pathString
        .replace('@file', app.store.is('features.hash', true)
        ? '[path][name].[contenthash:6][ext]'
        : '[path][name][ext]')
        .replace('@name', app.store.is('features.hash', true)
        ? '[name].[contenthash:6][ext]'
        : '[name][ext]');
    if (base === '@file' || base === '@name')
        return fileHandles(base);
    base = fileHandles(base);
    segments = segments.map(fileHandles);
    /* Parse `@` aliases. Should return an absolute path */
    if (base.startsWith(`@`))
        base = (0, exports.parseAlias)(app, base);
    /* Resolve any base path that isn't already absolute */
    if (!base.startsWith(`/`))
        base = (0, node_path_1.resolve)(app.context.projectDir, base);
    /* If segments were passed, resolve them against base */
    return segments.length ? (0, node_path_1.resolve)(base, ...segments) : base;
};
exports.path = path;
