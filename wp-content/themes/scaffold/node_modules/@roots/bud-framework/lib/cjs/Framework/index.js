"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Framework = void 0;
const bud_support_1 = require("@roots/bud-support");
const bud_support_2 = require("@roots/bud-support");
const __1 = require("../");
const frameworkProcess = __importStar(require("./framework.process"));
const lifecycle_1 = require("./lifecycle");
const methods = __importStar(require("./methods"));
const { isFunction, omit } = bud_support_2.lodash;
/**
 * Base {@link Framework} class
 *
 * @public
 */
class Framework {
    /**
     * Class constructor
     *
     * @param options - {@link Framework.Options | Framework constructor options}
     *
     * @public
     */
    constructor(options) {
        /**
         * Parent {@link Framework} instance
         *
         * @remarks
         * Is `null` if the current instance is the parent instance.
         *
         * @defaultValue null
         */
        this.root = this;
        /**
         * {@link @roots/container#Container} of child {@link Framework} instances
         *
         * @remarks
         * Is `null` if the current instance is a child instance.
         *
         * @defaultValue null
         */
        this.children = null;
        /**
         * True if ts-node has been invoked
         *
         * @public
         */
        this.usingTsNode = false;
        /**
         * @internal
         */
        this.lifecycle = lifecycle_1.lifecycle.bind(this);
        /**
         * Access a value which may or may not be a function.
         *
         * @remarks
         * If a value is a function **access** will call that function and return the result.
         *
         * If the value is not a function **access** will return its value.
         *
         * @example
         * ```js
         * const isAFunction = (option) => `option value: ${option}`
         * const isAValue = 'option value: true'
         *
         * access(isAFunction, true) // => `option value: true`
         * access(isAValue) // => `option value: true`
         * ```
         *
         * @public
         */
        this.maybeCall = methods.maybeCall.bind(this);
        /**
         * Gracefully shutdown {@link Framework} and registered {@link @roots/bud-framework#Service | Service instances}
         *
         * @example
         * ```js
         * bud.close()
         * ```
         *
         * @public
         */
        this.close = methods.close.bind(this);
        /**
         * Create a new {@link Container} instance
         *
         * @example
         * ```js
         * const myContainer = bud.container({key: methods.'value'})
         *
         * myContainer.get('key') // returns 'value'
         * ```
         *
         * @public
         */
        this.container = methods.container.bind(this);
        /**
         * Returns a {@link Framework | Framework instance} from the {@link Framework.children} container
         *
         * @remarks
         * An optional {@link tap} function can be provided to configure the {@link Framework} instance.
         *
         * @example
         * ```js
         * const name = 'plugin'
         * const tapFn = plugin => plugin.entry('main', 'main.js')
         *
         * bud.get(name, tapFn)
         * ```
         *
         * @public
         */
        this.get = methods.get.bind(this);
        /**
         * Instantiate a child instance and add to {@link Framework.children} container
         *
         * @remarks
         * **make** takes two parameters:
         *
         * - The **name** of the new compiler
         * - An optional callback to use for configuring the compiler.
         *
         * @example
         * ```js
         * bud.make('scripts', child => child.entry('app', 'app.js'))
         * ```
         *
         * @public
         */
        this.make = methods.make.bind(this);
        /**
         * Returns a {@link Locations} value as an absolute path
         *
         * @public
         */
        this.path = methods.path.bind(this);
        /**
         * Pipe a value through an array of functions. The return value of each callback is used as input for the next.
         *
         * @remarks
         * If no value is provided the value is assumed to be the {@link Framework} itself
         *
         * {@link sequence} is a non-mutational version of this method.
         *
         * @example
         * ```js
         * app.pipe(
         *   [
         *     value => value + 1,
         *     value => value + 1,
         *   ],
         *   1, // initial value
         * ) // resulting value is 3
         * ```
         *
         * @public
         */
        this.pipe = methods.pipe.bind(this);
        /**
         * Public path
         *
         * @remarks
         * Path from web root to assets
         *
         * @public
         */
        this.publicPath = methods.setPublicPath.bind(this);
        /**
         * Set a {@link @roots/bud-framework#Location | Location} value
         *
         * @remarks
         * The {@link Location.project} should be an absolute path.
         * All other directories should be relative (src, dist, etc.)
         * @see {@link Locations}
         *
         * @example
         * ```js
         * bud.setPath('@src', 'custom/src')
         * ```
         *
         * @param this - {@link Framework}
         * @param args - path parts
         *
         * @public
         */
        this.setPath = methods.setPath.bind(this);
        /**
         * By default it is assumed that assets are served from webroot (`/`).
         * You can use this method to replace this value for apps served from
         * a subdirectory.
         *
         * @example
         * Set the default path using a string
         *
         * ```js
         * app.setPublicPath('/app/themes/sage/dist')
         * ```
         *
         * @example
         * Set the publicPath using a function.
         *
         * ```js
         * app.setPublicPath(publicPath => {
         *   return `web/assets/${publicPath}`
         * })
         * ```
         *
         * @public
         */
        this.setPublicPath = methods.setPublicPath.bind(this);
        /**
         * Run a value through an array of syncronous, non-mutational functions.
         *
         * @remarks
         * Unlike {@link pipe} the value returned from each function is ignored.
         *
         * @public
         */
        this.sequence = methods.sequence.bind(this);
        /**
         * Execute a callback
         *
         * @remarks
         * Callback is provided {@link Framework | the Framework instance} as a parameter.
         *
         * @example
         * ```js
         * bud.tap(bud => {
         *   // do something with bud
         * })
         * ```
         *
         * @example
         * Lexical scope is bound to Framework where applicable, so it
         * is possible to reference the Framework using `this`.
         *
         * ```js
         * bud.tap(function () {
         *  // do something with this
         * })
         * ```
         *
         * @public
         */
        this.tap = methods.tap.bind(this);
        /**
         * Executes a function if a given test is `true`.
         *
         * @remarks
         * - The first parameter is the conditional check.
         * - The second parameter is the function to run if `true`.
         * - The third parameter is optional; executed if the conditional is not `true`.
         *
         * @example
         * Only produce a vendor bundle when running in `production` {@link Mode}:
         *
         * ```js
         * bud.when(bud.isProduction, () => bud.vendor())
         * ```
         *
         * @example
         * Use `eval` sourcemap in development mode and `hidden-source-map` in production:
         *
         * ```js
         * bud.when(
         *   bud.isDevelopment,
         *   () => bud.devtool('eval'),
         *   () => bud.devtool('hidden-source-map'),
         * )
         * ```
         *
         * @public
         */
        this.when = methods.when.bind(this);
        /**
         * Bind method to {@link Framework | Framework instance}
         *
         * @public
         */
        this.bindMethod = methods.bindMethod.bind(this);
        /**
         * Read and write json files
         *
         * @public
         */
        this.json = bud_support_2.parsers.json5;
        /**
         * Read and write yaml files
         *
         * @public
         */
        this.yml = bud_support_2.parsers.yml;
        /**
         * timer util
         *
         * @public
         */
        this._hrtime = process.hrtime();
        this.options = options;
        this.context = options.context;
        this._mode = this.options.mode;
        this._name = this.options.name;
        this.store = new __1.Store(this, options.config);
        frameworkProcess.initialize(this);
        if (!options.childOf) {
            this.children = this.container();
            this.root = this;
        }
        else {
            this.root = options.childOf;
        }
        this.lifecycle = lifecycle_1.lifecycle.bind(this);
        this.services = options.services;
        Object.entries(methods).map(([key, method]) => {
            if (!isFunction(method)) {
                this.error(`framework ctor`, `method "${key}" is not a function`);
            }
            this[key] = method.bind(this);
        });
        this.logger = new __1.Logger(this);
    }
    get name() {
        return this._name;
    }
    get mode() {
        return this._mode;
    }
    /**
     * True when current instance is the parent instance
     *
     * @readonly
     */
    get isRoot() {
        return this.name === this.root.name;
    }
    /**
     * True when current instance is a child instance
     *
     * @readonly
     */
    get isChild() {
        return this.name !== this.root.name;
    }
    /**
     * True when {@link Framework} has children
     *
     * @readonly
     */
    get hasChildren() {
        return this.children?.getEntries().length > 0;
    }
    /**
     * True when {@link Framework.mode} is `production`
     *
     * @public
     */
    get isProduction() {
        return this.mode === 'production';
    }
    /**
     * True when {@link Framework.mode} is `development`
     *
     * @public
     */
    get isDevelopment() {
        return this.mode === 'development';
    }
    /**
     * Log a message
     *
     * @public
     * @decorator `@bind`
     */
    log(...messages) {
        this.logger?.instance && this.logger.instance.log(...messages);
        return this;
    }
    /**
     * Log an `info` level message
     *
     * @public
     * @decorator `@bind`
     */
    info(...messages) {
        this.logger?.instance && this.logger.instance.info(...messages);
        return this;
    }
    /**
     * Log a `success` level message
     *
     * @public
     * @decorator `@bind`
     */
    success(...messages) {
        this.logger?.instance && this.logger.instance.success(...messages);
        return this;
    }
    /**
     * Log a `warning` level message
     *
     * @public
     * @decorator `@bind`
     */
    warn(...messages) {
        this.logger?.instance && this.logger.instance.warn(...messages);
        return this;
    }
    /**
     * Log a `warning` level message
     *
     * @public
     * @decorator `@bind`
     */
    time(...messages) {
        this.logger?.instance && this.logger.instance.time(...messages);
        return this;
    }
    /**
     * Log a `warning` level message
     *
     * @public
     * @decorator `@bind`
     */
    await(...messages) {
        this.logger?.instance && this.logger.instance.await(...messages);
        return this;
    }
    /**
     * Log a `warning` level message
     *
     * @public
     * @decorator `@bind`
     */
    complete(...messages) {
        this.logger?.instance && this.logger.instance.complete(...messages);
        return this;
    }
    /**
     * Log a `warning` level message
     *
     * @public
     * @decorator `@bind`
     */
    timeEnd(...messages) {
        this.logger?.instance && this.logger.instance.timeEnd(...messages);
        return this;
    }
    /**
     * Log and display a debug message.
     *
     * @remarks
     * This error is fatal and will kill the process
     *
     * @public
     * @decorator `@bind`
     */
    debug(...messages) {
        // eslint-disable-next-line no-console
        this.context.stdout.write(`${(0, bud_support_2.highlight)((0, bud_support_2.format)(messages, {
            callToJSON: false,
            maxDepth: 8,
            printFunctionName: false,
            escapeString: false,
        }))}`);
    }
    /**
     * Log and display an error.
     *
     * @remarks
     * This error is fatal and will kill the process
     *
     * @public
     * @decorator `@bind`
     */
    error(...messages) {
        this.logger.instance.error(...messages);
        if (this.isProduction) {
            process.exitCode = 1;
            process.exit();
        }
    }
    /**
     * Dump object and return Framework
     */
    dump(obj, options) {
        if (!this.context.args.verbose)
            return;
        const prettyFormatOptions = omit(options, [
            'prefix',
            'language',
            'ignoreIllegals',
        ]);
        // eslint-disable-next-line no-console
        process.stdout.write((0, bud_support_1.boxen)((0, bud_support_2.highlight)((0, bud_support_2.format)(obj, {
            callToJSON: false,
            maxDepth: 8,
            printFunctionName: false,
            escapeString: false,
            ...prettyFormatOptions,
        }), {
            language: options?.language ?? 'typescript',
            ignoreIllegals: options?.ignoreIllegals ?? true,
        }), {
            title: options.prefix ?? 'object dump',
            borderStyle: 'round',
        }));
        return this;
    }
    _hrdiff() {
        const diff = process.hrtime(this._hrtime);
        return diff[0] * 1000 + diff[1] / 1000000;
    }
}
__decorate([
    bud_support_2.bind
], Framework.prototype, "log", null);
__decorate([
    bud_support_2.bind
], Framework.prototype, "info", null);
__decorate([
    bud_support_2.bind
], Framework.prototype, "success", null);
__decorate([
    bud_support_2.bind
], Framework.prototype, "warn", null);
__decorate([
    bud_support_2.bind
], Framework.prototype, "time", null);
__decorate([
    bud_support_2.bind
], Framework.prototype, "await", null);
__decorate([
    bud_support_2.bind
], Framework.prototype, "complete", null);
__decorate([
    bud_support_2.bind
], Framework.prototype, "timeEnd", null);
__decorate([
    bud_support_2.bind
], Framework.prototype, "debug", null);
__decorate([
    bud_support_2.bind
], Framework.prototype, "error", null);
__decorate([
    bud_support_2.bind
], Framework.prototype, "dump", null);
exports.Framework = Framework;
