"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hooks = void 0;
const bud_framework_1 = require("@roots/bud-framework");
const bud_support_1 = require("@roots/bud-support");
const { get, isFunction, isUndefined, set } = bud_support_1.lodash;
/**
 * Hooks and events registry
 *
 * @remarks
 * Supports async and sync value hooks as well as asyncronous events.
 *
 * @example
 * Add a new entry to the `webpack.externals` configuration:
 *
 * ```ts
 * hooks.on(
 *   'build.externals',
 *   externals => ({
 *     ...externals,
 *     $: 'jquery',
 *   }),
 * )
 * ```
 *
 * @example
 * Change the `webpack.output.filename` format:
 *
 * ```ts
 * hooks.on(
 *   'build.output.filename',
 *   () => '[name].[hash:4]',
 * )
 * ```
 *
 * @example
 * Filter a value through any registered hooks:
 *
 * ```ts
 * hooks.filter('build.output.filename', DEFAULT_VALUE)
 * ```
 *
 * @example
 * Filter an async value through any registered hooks:
 *
 * ```ts
 * await hooks.filterAsync('my-event-name', async () => DEFAULT_VALUE)
 * ```
 *
 * @public
 */
class Hooks extends bud_framework_1.Service {
    constructor() {
        super(...arguments);
        /**
         * @internal
         */
        this.ident = 'hooks';
    }
    /**
     * hook getter
     *
     * @internal
     * @decorator `@bind`
     */
    get(path) {
        return get(this.repository, path);
    }
    /**
     * hook setter
     *
     * @internal
     * @decorator `@bind`
     */
    set(key, value) {
        set(this.repository, key, value);
        return this;
    }
    /**
     * Register a function to filter a value.
     *
     * @remarks
     * If a filter calls for this name the function is then run,
     * passing whatever data along for modification. If more than one
     * hook is registered to a name, they will be called sequentially
     * in the order they were registered, with each hook's output used
     * as the input for the next.
     *
     * @example
     * ```js
     * app.hooks.on(
     *   'namespace.key',
     *   value => 'replaced by this string',
     * )
     * ```
     *
     * @public
     * @decorator `@bind`
     */
    on(id, input) {
        const retrieved = this.has(id) ? this.get(id) : [];
        const normal = Array.isArray(retrieved) ? retrieved : [retrieved];
        const callback = typeof input === 'function' ? input : () => input;
        this.set(id, [...normal, callback]);
        return this.app;
    }
    /**
     * Register a function to filter a value.
     *
     * @remarks
     * If a filter calls for this name the function is then run,
     * passing whatever data along for modification. If more than one
     * hook is registered to a name, they will be called sequentially
     * in the order they were registered, with each hook's output used
     * as the input for the next.
     *
     * @example
     * ```js
     * app.hooks.on(
     *   'namespace.key',
     *   value => 'replaced by this string',
     * )
     * ```
     *
     * @public
     * @decorator `@bind`
     */
    async(id, input) {
        const retrieved = this.has(id) ? this.get(id) : [];
        const normal = Array.isArray(retrieved) ? retrieved : [retrieved];
        const callback = typeof input === 'function' ? input : () => input;
        this.set(id, [...normal, callback]);
        return this.app;
    }
    /**
     * Hooks filter
     *
     * @remarks
     * The other side of bud.hooks.on. Passes a key and a value. If
     * any filters are registered on that key they will transform
     * the output before it is returned.
     *
     * @example
     * ```js
     * bud.hooks.filter(
     *   'namespace.Key.event',
     *   ['array', 'of', 'items'],
     * )
     * ```
     *
     * @public
     * @decorator `@bind`
     */
    filter(id, value) {
        if (!this.has(id)) {
            if (isUndefined(value))
                return undefined;
            return isFunction(value) ? value() : value;
        }
        const retrieved = this.get(id) ?? [];
        const normal = Array.isArray(retrieved) ? retrieved : [retrieved];
        return normal.reduce((accumulated, current) => {
            const next = isFunction(current) ? current(accumulated) : current;
            if (this.app.context.args.debug)
                this.app.info(`hooks.filter`, id, `=>`, next);
            return next;
        }, value);
    }
    /**
     * Asyncronous hook filter
     *
     * @remarks
     * This method is used to filter a hook event.
     *
     * @example
     * ```js
     * bud.hooks.filter(
     *   'namespace.Key.event',
     *   ['array', 'of', 'items'],
     * )
     * ```
     *
     * @public
     * @decorator `@bind`
     */
    async filterAsync(id, value) {
        if (!this.has(id)) {
            if (isUndefined(value))
                return;
            return isFunction(value) ? await value() : value;
        }
        const retrieved = this.get(id) ?? [];
        const normal = Array.isArray(retrieved) ? retrieved : [retrieved];
        return await normal.reduce(async (promised, current) => {
            const value = await promised;
            return isFunction(current) ? await current(value) : current;
        }, value);
    }
    /**
     * Register an action (called with {@link Hooks.fire})
     *
     * @public
     * @decorator `@bind`
     */
    action(id, ...action) {
        const retrieved = this.has(id) ? this.get(id) : [];
        const normal = Array.isArray(retrieved) ? retrieved : [retrieved];
        this.app.log({
            message: `registering action: ${id}`,
            suffix: bud_support_1.chalk.dim(`${normal.length + 1} registered`),
        });
        this.set(id, [...normal, ...action]);
        return this.app;
    }
    /**
     * Fire actions registered to an event.
     *
     * @example
     * ```js
     * await app.hooks.fire('namespace.key')
     * ```
     *
     * @public
     * @decorator `@bind`
     */
    async fire(id) {
        if (!this.has(id))
            return;
        const retrieved = this.get(id);
        const normal = Array.isArray(retrieved) ? retrieved : [retrieved];
        await normal.reduce(async (promised, current, increment) => {
            await promised;
            this.app.log({
                message: `firing action ${id}`,
                suffix: bud_support_1.chalk.dim(`${increment + 1}/${normal.length}`),
            });
            return await current(this.app);
        }, Promise.resolve());
        return this.app;
    }
}
__decorate([
    bud_support_1.bind
], Hooks.prototype, "get", null);
__decorate([
    bud_support_1.bind
], Hooks.prototype, "set", null);
__decorate([
    bud_support_1.bind
], Hooks.prototype, "on", null);
__decorate([
    bud_support_1.bind
], Hooks.prototype, "async", null);
__decorate([
    bud_support_1.bind
], Hooks.prototype, "filter", null);
__decorate([
    bud_support_1.bind
], Hooks.prototype, "filterAsync", null);
__decorate([
    bud_support_1.bind
], Hooks.prototype, "action", null);
__decorate([
    bud_support_1.bind
], Hooks.prototype, "fire", null);
exports.Hooks = Hooks;
